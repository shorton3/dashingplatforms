// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// be/be_codegen.cpp:948

#include <sstream>
#include <string>
using namespace std;

#include "platformConfigI.h"

#include "platform/common/Defines.h"
#include "platform/common/ConnectionSetNames.h"

#include "platform/datamgr/DataManager.h"
#include "platform/datamgr/DbConnectionHandle.h"

#include "platform/logger/Logger.h"
#include "platform/logger/LoggerCommon.h"

#include "platform/utilities/SystemInfo.h"

// Implementation skeleton constructor
platformConfig_platformConfig_I_i::platformConfig_platformConfig_I_i (void)
{
}

// Implementation skeleton destructor
platformConfig_platformConfig_I_i::~platformConfig_platformConfig_I_i (void)
{
}

void platformConfig_platformConfig_I_i::getLogLevels (
    platformConfig::platformConfigLogLevels_out logLevels
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  // Add your implementation here


   TRACELOG(DEBUGLOG, CLIENTAGENTLOG, "Received request to get log levels", 0,0,0,0,0,0);
   // Declare the sequence
   platformConfig::platformConfigLogLevels_var logLevels_var;
   // Allocate the size
   platformConfig::platformConfigLogLevels* tempSequence;
   ACE_NEW(tempSequence, platformConfig::platformConfigLogLevels(MAX_LOG_SUBSYSTEM));
   // Pass ownership to the _var since ACE_NEW cannot assign to T_vars directly
   logLevels_var = tempSequence;
   logLevels_var->length(MAX_LOG_SUBSYSTEM);
   // Populate the sequence
   for (int i = ALL_LOG_SUBSYSTEMS; i < MAX_LOG_SUBSYSTEM; i++)
   {
      // Declare the single log level structure
      platformConfig::platformConfigLogLevel_var logLevel;
      // Allocate
      platformConfig::platformConfigLogLevel* tempStructure;
      ACE_NEW(tempStructure, platformConfig::platformConfigLogLevel); 

      // Populate the structure
      tempStructure->subsystemEnum = i;
      tempStructure->subsystemName = (const char*)(logSubSystemName[i]);
      tempStructure->severityLevel = (int)Logger::getSubsystemLogLevel((LogSubSystemType)i);

      // Pass ownership to the _var since ACE_NEW cannot assign to T_vars directly
      logLevel = tempStructure;

      // Put the single log level structure in the sequence/array
      logLevels_var[CORBA::ULong(i)] = logLevel;
      ACE_CHECK;
   }//end for
   // Return the sequence
   logLevels = logLevels_var._retn();
   
}

void platformConfig_platformConfig_I_i::setLogLevel (
    const platformConfig::platformConfigLogLevel & logLevel
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  // Add your implementation here

   // Set the single log level
   TRACELOG(DEBUGLOG, CLIENTAGENTLOG, "Received request to set subsystem %d log level to %d",
      logLevel.subsystemEnum, logLevel.severityLevel,0,0,0,0);
   Logger::setSubsystemLogLevel((LogSubSystemType)logLevel.subsystemEnum, (LogSeverityType)logLevel.severityLevel);
   ACE_CHECK;

   // Set the log level in the database, so reserve a connection
   DbConnectionHandle* connectionHandle = DataManager::reserveConnection(CLIENT_AGENT_CONNECTION);
   if (connectionHandle == NULL)
   {
      TRACELOG(ERRORLOG, CLIENTAGENTLOG, "Error reserving connection",0,0,0,0,0,0);
      return;
   }//end if
   else
   {
      TRACELOG(DEBUGLOG, CLIENTAGENTLOG, "Successfully reserved Logger ConnectionSet Connection",0,0,0,0,0,0);
   }//end else

   // Build the update sql statement
   ostringstream ostr;
   ostr << "Update platform.loglevels set LogLevel=" << logLevel.severityLevel 
        << " where SubSystem=" << logLevel.subsystemEnum 
        << " and NEID='" << SystemInfo::getLocalNEID() << "';" << ends;
   // Execute the query against the database
   if (connectionHandle->executeCommand(ostr.str().c_str()) == ERROR)
   {
      TRACELOG(ERRORLOG, CLIENTAGENTLOG, "Log Level update execution failed",0,0,0,0,0,0);
   }//end if

   // Close the results, release the connection
   connectionHandle->closeCommandResult();
   DataManager::releaseConnection(connectionHandle);

}

void platformConfig_platformConfig_I_i::setLogLevels (
    const platformConfig::platformConfigLogLevels & logLevels
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  // Add your implementation here

   TRACELOG(DEBUGLOG, CLIENTAGENTLOG, "Received request to update/set all subsystem log levels",0,0,0,0,0,0);
   // Check to see if the sequence length is the same as the Max Log Subsystems
   if (logLevels.length() != MAX_LOG_SUBSYSTEM)
   {
      TRACELOG(WARNINGLOG, CLIENTAGENTLOG, "Attempt to set Log Levels has too few elements: %d, should be %d",
         logLevels.length(),MAX_LOG_SUBSYSTEM,0,0,0,0);
   }//end if

   // Set the log level in the database, so reserve a connection
   DbConnectionHandle* connectionHandle = DataManager::reserveConnection(CLIENT_AGENT_CONNECTION);
   if (connectionHandle == NULL)
   {
      TRACELOG(ERRORLOG, CLIENTAGENTLOG, "Error reserving connection",0,0,0,0,0,0);
      return;
   }//end if
   else
   {
      TRACELOG(DEBUGLOG, CLIENTAGENTLOG, "Successfully reserved Logger ConnectionSet Connection",0,0,0,0,0,0);
   }//end else

   // Populate the Log Levels
   ostringstream ostr;
   for (unsigned int i = 0; i < logLevels.length(); i++)
   {
      Logger::setSubsystemLogLevel((LogSubSystemType)logLevels[i].subsystemEnum, 
            (LogSeverityType)logLevels[i].severityLevel);
      ACE_CHECK;

      // Build the update sql statement -- append each command to be executed at once
      ostr << "Update platform.loglevels set LogLevel=" << logLevels[i].severityLevel 
           << " where SubSystem=" << logLevels[i].subsystemEnum 
           << " and NEID='" << SystemInfo::getLocalNEID() << "'; ";
   }//end for
   ostr << ends;

   // Execute the query against the database
   if (connectionHandle->executeCommand(ostr.str().c_str()) == ERROR)
   {
      TRACELOG(ERRORLOG, CLIENTAGENTLOG, "Log Level update execution failed",0,0,0,0,0,0);
   }//end if

   // Close the results, release the connection
   connectionHandle->closeCommandResult();
   DataManager::releaseConnection(connectionHandle);
}

