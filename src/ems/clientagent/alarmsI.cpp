// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// be/be_codegen.cpp:948

#include <sstream>
#include <string>
using namespace std;

#include "alarmsI.h"

#include "platform/common/Defines.h"
#include "platform/common/ConnectionSetNames.h"

#include "platform/datamgr/DataManager.h"
#include "platform/datamgr/DbConnectionHandle.h"

#include "platform/logger/Logger.h"


// Implementation skeleton constructor
alarms_alarmInterface_i::alarms_alarmInterface_i (void)
{
}

// Implementation skeleton destructor
alarms_alarmInterface_i::~alarms_alarmInterface_i (void)
{
}

void alarms_alarmInterface_i::getOutstandingAlarms (
    alarms::AlarmNotificationSequence_out outstandingAlarms
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  // Add your implementation here

   TRACELOG(DEBUGLOG, CLIENTAGENTLOG, "Received request to get Outstanding Alarms", 0,0,0,0,0,0);

//TODO:
   // For now, reserve a Logger Connection. We ultimately need to decide how many
   // connection we need and who will share them
   DbConnectionHandle* connectionHandle = DataManager::reserveConnection(CLIENT_AGENT_CONNECTION);
   if (connectionHandle == NULL)
   {
      TRACELOG(ERRORLOG, CLIENTAGENTLOG, "Error reserving connection",0,0,0,0,0,0);
      // Cannot return null
      alarms::AlarmNotificationSequence_var outstandingAlarms_var;
      outstandingAlarms = outstandingAlarms_var._retn();
      return;
   }//end if
   else
   {
      TRACELOG(DEBUGLOG, CLIENTAGENTLOG, "Successfully reserved ConnectionSet Connection",0,0,0,0,0,0);
   }//end else

   // Query the outstandingAlarms table on the EMS for all 'active' (not yet cleared)
   // alarms. Only need to retrieve the 'ApplicableToNEID' field for clients/NOCs
   // HERE, we need to JOIN AlarmsOutstanding and AlarmsInventory to get the user severity
   string outstandingAlarmsQuery = "Select AO.ApplicableToNEID, AO.AlarmCode, AO.ManagedObject, " 
      "AO.ManagedObjectInstance, AO.TimeStamp, AO.Acknowledgement, AI.UserSeverity "
      "from platform.AlarmsOutstanding AO, platform.AlarmsInventory AI where AI.AlarmCode=AO.AlarmCode " 
      "and IsCleared=false;";

   // Execute the query against the database
   if (connectionHandle->executeCommand(outstandingAlarmsQuery.c_str()) == ERROR)
   {
      TRACELOG(ERRORLOG, CLIENTAGENTLOG, "AlarmsOutstanding query execution failed",0,0,0,0,0,0);
      DataManager::releaseConnection(connectionHandle);
      // Cannot return null
      alarms::AlarmNotificationSequence_var outstandingAlarms_var;
      outstandingAlarms = outstandingAlarms_var._retn();
      return;
   }//end if
 
   // Check the results
   int columnCount = connectionHandle->getColumnCount();
   int rowCount = connectionHandle->getRowCount();
   // Do some checks to see if the number of columns returned is zero! This indicates a schema error!
   if (columnCount == 0)
   {
      TRACELOG(ERRORLOG, CLIENTAGENTLOG, "No columns returned in result set, possible schema error",0,0,0,0,0,0);
      connectionHandle->closeCommandResult();
      DataManager::releaseConnection(connectionHandle);
      // Cannot return null
      alarms::AlarmNotificationSequence_var outstandingAlarms_var;
      outstandingAlarms = outstandingAlarms_var._retn();
      return;
   }//end if
   // Check to see if there are any rows returned
   else if (rowCount == 0)
   {
      TRACELOG(DEBUGLOG, CLIENTAGENTLOG, "Currently no outstanding alarms exist",0,0,0,0,0,0);
      connectionHandle->closeCommandResult();
      DataManager::releaseConnection(connectionHandle);
      return;
   }//end if

   // Don't assume the order of the columns
   int neidIndex = connectionHandle->getColumnIndex("ApplicableToNEID");
   int alarmCodeIndex = connectionHandle->getColumnIndex("AlarmCode");
   int mObjectIndex = connectionHandle->getColumnIndex("ManagedObject");
   int mObjectInstanceIndex = connectionHandle->getColumnIndex("ManagedObjectInstance");
   int timeStampIndex = connectionHandle->getColumnIndex("TimeStamp");
   int ackIndex = connectionHandle->getColumnIndex("Acknowledgement");
   int severityIndex = connectionHandle->getColumnIndex("UserSeverity");

   // Declare the sequence
   alarms::AlarmNotificationSequence_var outstandingAlarms_var;
   // Allocate the size
   alarms::AlarmNotificationSequence* tempSequence;
   ACE_NEW(tempSequence, alarms::AlarmNotificationSequence(rowCount));
   // Pass ownership to the _var since ACE_NEW cannot assign to T_vars directly
   outstandingAlarms_var = tempSequence;
   outstandingAlarms_var->length(rowCount);
   // Populate the sequence
   for (int row = 0; row < rowCount; row++)
   {
      // Declare the single AlarmNotification structure
      alarms::AlarmNotification_var alarmNotification;
      // Allocate
      alarms::AlarmNotification* tempStructure;
      ACE_NEW(tempStructure, alarms::AlarmNotification);

      // Populate the structure
      // NEID should be 'ApplicableToNEID' in the schema
      tempStructure->neid = connectionHandle->getStringValueAt(row, neidIndex).c_str();
      // AlarmCode
      tempStructure->code = connectionHandle->getShortValueAt(row, alarmCodeIndex);
      // Managed Object Type
      tempStructure->mObject = connectionHandle->getShortValueAt(row, mObjectIndex);
      // Managed Object instance
      tempStructure->mObjectInstance = connectionHandle->getIntValueAt(row, mObjectInstanceIndex);
      // Alarm severity. Could be CLEAR, but here, we will only send active
      // alarms from the table that have not yet cleared.
      tempStructure->sev = (alarms::Severity)connectionHandle->getShortValueAt(row, severityIndex);
      // Timestamp
      tempStructure->tStamp = connectionHandle->getTimestampValueAt(row, timeStampIndex).c_str();
      // User acknowledgements
      tempStructure->ack = connectionHandle->getStringValueAt(row, ackIndex).c_str();

      // Pass ownership to the _var since ACE_NEW cannot assign to T_vars directly
      alarmNotification = tempStructure;

      // Put the single alarm record in the sequence/array
      outstandingAlarms_var[CORBA::ULong(row)] = alarmNotification;
      ACE_CHECK;
   }//end for

   // Close the results, release the connection
   connectionHandle->closeCommandResult();
   DataManager::releaseConnection(connectionHandle);

   // Return the sequence
   outstandingAlarms = outstandingAlarms_var._retn();

}

void alarms_alarmInterface_i::getAlarmInventory (
    alarms::AlarmInformationSequence_out alarmInventory
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  // Add your implementation here

   TRACELOG(DEBUGLOG, CLIENTAGENTLOG, "Received request to get Alarms Inventory", 0,0,0,0,0,0);

//TODO:
   // For now, reserve a Logger Connection. We ultimately need to decide how many
   // connection we need and who will share them
   DbConnectionHandle* connectionHandle = DataManager::reserveConnection(CLIENT_AGENT_CONNECTION);
   if (connectionHandle == NULL)
   {
      TRACELOG(ERRORLOG, CLIENTAGENTLOG, "Error reserving connection",0,0,0,0,0,0);
      // Cannot return null
      alarms::AlarmInformationSequence_var inventoryAlarms_var;
      alarmInventory = inventoryAlarms_var._retn();
      return;
   }//end if
   else
   {
      TRACELOG(DEBUGLOG, CLIENTAGENTLOG, "Successfully reserved ConnectionSet Connection",0,0,0,0,0,0);
   }//end else

   // Query the AlarmsInventory table on the EMS for all possible Alarms in the system
   // Only return the UserSeverity field
   string alarmsInventoryQuery = "Select AlarmCode, Category, UserSeverity, Description, Resolution "
      "from platform.AlarmsInventory;";

   // Execute the query against the database
   if (connectionHandle->executeCommand(alarmsInventoryQuery.c_str()) == ERROR)
   {
      TRACELOG(ERRORLOG, CLIENTAGENTLOG, "Alarms Inventory query execution failed",0,0,0,0,0,0);
      DataManager::releaseConnection(connectionHandle);
      // Cannot return null
      alarms::AlarmInformationSequence_var inventoryAlarms_var;
      alarmInventory = inventoryAlarms_var._retn();
      return;
   }//end if

   // Check the results
   int columnCount = connectionHandle->getColumnCount();
   int rowCount = connectionHandle->getRowCount();
   // Do some checks to see if the number of columns returned is zero! This indicates a schema error!
   if (columnCount == 0)
   {
      TRACELOG(ERRORLOG, CLIENTAGENTLOG, "No columns returned in result set, possible schema error",0,0,0,0,0,0);
      connectionHandle->closeCommandResult();
      DataManager::releaseConnection(connectionHandle);
      // Cannot return null
      alarms::AlarmInformationSequence_var inventoryAlarms_var;
      alarmInventory = inventoryAlarms_var._retn();
      return;
   }//end if
   // Check to see if there are any rows returned
   else if (rowCount == 0)
   {
      TRACELOG(DEBUGLOG, CLIENTAGENTLOG, "Currently no alarm default datafill exists; possible schema error",0,0,0,0,0,0);
      connectionHandle->closeCommandResult();
      DataManager::releaseConnection(connectionHandle);
      // Cannot return null
      alarms::AlarmInformationSequence_var inventoryAlarms_var;
      alarmInventory = inventoryAlarms_var._retn();
      return;
   }//end if

   // Don't assume the order of the columns
   int alarmCodeIndex = connectionHandle->getColumnIndex("AlarmCode");
   int catagoryIndex = connectionHandle->getColumnIndex("Category");
   int severityIndex = connectionHandle->getColumnIndex("UserSeverity");
   int descIndex = connectionHandle->getColumnIndex("Description");
   int resIndex = connectionHandle->getColumnIndex("Resolution");

   // Declare the sequence
   alarms::AlarmInformationSequence_var inventoryAlarms_var;
   // Allocate the size
   alarms::AlarmInformationSequence* tempSequence;
   ACE_NEW(tempSequence, alarms::AlarmInformationSequence(rowCount));
   // Pass ownership to the _var since ACE_NEW cannot assign to T_vars directly
   inventoryAlarms_var = tempSequence;
   inventoryAlarms_var->length(rowCount);
   // Populate the sequence
   for (int row = 0; row < rowCount; row++)
   {
      // Declare the single AlarmInformation structure
      alarms::AlarmInformation_var alarmInformation;
      // Allocate
      alarms::AlarmInformation* tempStructure;
      ACE_NEW(tempStructure, alarms::AlarmInformation);

      // Populate the structure
      // AlarmCode
      tempStructure->code = connectionHandle->getShortValueAt(row, alarmCodeIndex);
      // Category
      tempStructure->aCategory = (alarms::AlarmCategory)connectionHandle->getShortValueAt(row, catagoryIndex);
      // Alarm severity. Could be CLEAR, but here, we will only send active
      // alarms from the table that have not yet cleared.
      tempStructure->sev = (alarms::Severity)connectionHandle->getShortValueAt(row, severityIndex);
      // Description
      tempStructure->desc = connectionHandle->getStringValueAt(row, descIndex).c_str();
      // Resolution
      tempStructure->res = connectionHandle->getStringValueAt(row, resIndex).c_str();

      // Pass ownership to the _var since ACE_NEW cannot assign to T_vars directly
      alarmInformation = tempStructure;

      // Put the single alarm record in the sequence/array
      inventoryAlarms_var[CORBA::ULong(row)] = alarmInformation;
      ACE_CHECK;
   }//end for

   // Close the results, release the connection
   connectionHandle->closeCommandResult();
   DataManager::releaseConnection(connectionHandle);

   // Return the sequence
   alarmInventory = inventoryAlarms_var._retn();

}

